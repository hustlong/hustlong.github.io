<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on 龙大侠</title>
    <link>/blog/</link>
    <description>Recent content in Blogs on 龙大侠</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 13 May 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>写在2018母亲节</title>
      <link>/blog/2018-05-13-%E5%86%99%E5%9C%A82018%E6%AF%8D%E4%BA%B2%E8%8A%82/</link>
      <pubDate>Sun, 13 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/2018-05-13-%E5%86%99%E5%9C%A82018%E6%AF%8D%E4%BA%B2%E8%8A%82/</guid>
      <description>待补坑。。。</description>
    </item>
    
    <item>
      <title>经典排序算法总结与Go实现</title>
      <link>/blog/2017-06-29-%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ego%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Thu, 29 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/blog/2017-06-29-%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ego%E5%AE%9E%E7%8E%B0/</guid>
      <description>学习Go语言第二周，本周任务尝试实现七大经典排序算法以及分析算法复杂度、优劣及应用场景等，七大经典算法分别为冒泡排序，插入排序，选择排序，希尔排序，归并排序，快速排序，堆排序。 冒泡排序  思路  正如“冒泡”二字，我的理解是重复依次比较相邻的两个数，大的数放在后面，小的数放在前面，一直重复到没有任何一对数字需要交换位置为止。就像冒泡一样，大的数不断浮上来。
 伪代码  do swapped = false for i = 1 to indexOfLastUnsortedElement-1 if leftElement &amp;gt; rightElement swap(leftElement, rightElement) swapped = true; swapCounter++ while swapped   Go实现  func Bubble_Sort(arr []int) { swapped := true len := len(arr) for swapped { swapped = false for i := 0; i &amp;lt; len-1; i++ { if arr[i] &amp;gt; arr[i+1] { arr[i], arr[i+1] = arr[i+1], arr[i] swapped = true } } } }  选择排序  思路  先假设第一个元素为最小值，然后与剩余的 len-1 个元素依次进行比较，标记最小数的位置，如果有更小的数，则在进行下一轮遍历比较之前交换位置。</description>
    </item>
    
    <item>
      <title>Android应用启动瞬间白屏</title>
      <link>/blog/2017-04-17-android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E7%9E%AC%E9%97%B4%E7%99%BD%E5%B1%8F/</link>
      <pubDate>Mon, 17 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>/blog/2017-04-17-android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E7%9E%AC%E9%97%B4%E7%99%BD%E5%B1%8F/</guid>
      <description>Android App 启动白屏问题，老司机当然不会允许自己的应用出现这种情况！
问题 遇到用户反映在打开app的时候有大概不到一秒钟的白屏时间，无论怎样优化启动Activity ，这个白屏时间都无法避免（也有可能是黑屏）。这个问题不简单啊！然后果断去尝试启动一些比较成熟的应用，例如，摩拜、咸鱼、得到、WhatsApp、Quora、 等等都有白屏问题（其中摩拜是黑屏问题）。不过微信、qq、百度云、微博都没有这个问题，ofo小黄车也没有白屏问题，哈哈哈。
那么问题来了？
到底是什么原因导致了这个白屏or黑屏时间？
解决 先去搜索引擎找一下答案，第一个搜索结果就解决了这个问题。
之前的启动页就是按照普通的Activity思路去写的，如下：
/** * Created by biglong on 2017/4/17. */ public class SplashActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_splash); //据说，不推荐这种写法，容易内存泄漏 new Handler().postDelayed( new Runnable() { @Override public void run() { startActivity(new Intent(SplashActivity.this ,MainActivity.class)); finish(); } }, 1000 ); } }  问题可能就出现在方法 setContentView 上。我们按照 博客 上面的方法来重新设计该启动页:
创建 XML Drawable #在 res/drawable/ 里面 &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?</description>
    </item>
    
    <item>
      <title>初识 Android Things（0x01）</title>
      <link>/blog/2017-04-15-%E5%88%9D%E8%AF%86-android-things0x01/</link>
      <pubDate>Sat, 15 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>/blog/2017-04-15-%E5%88%9D%E8%AF%86-android-things0x01/</guid>
      <description>谷歌推出的 Things 物联网操作系统也有小半年时间了，刚刚推出的时候就开始了解相关资料，跃跃欲试，不过工作原因一直没来得及，现在转眼已是小半年时间了，现在出发也不晚，老司机，走起～
Android Things 是什么  Build connected devices for a wide variety of consumer, retail, and industrial applications
 2016年12月，谷歌发布了物联网操作系统 Android Things，Things 可以说是 Android 系统的一个分支。结合谷歌为物联网设备推出的通讯协议Weave，Android Things将在谷歌物联网战略中发挥重要作用。
Things 的前身是谷歌于2015年发布的物联网底层操作系统 Brillo，Brillo 源于Android，是对Android底层的一个细化，得到了Android的全部支持，比如蓝牙、Wifi等技术，并且能耗很低，安全性很高，任何设备制造商都可以直接使用，是一个完全端到端的应用。
不同的是，Brillo把C++作为主要开发环境，它的开发和部署明显不同于常规Android开发，因此这对于 Android 开发者并不友好，而Android Things则面向所有Java开发者，不管开发者有没有移动开发经验，有经验更容易上手，Android Things系统支持原始Android SDK中的一个子集，开发环境就用 Android Studio，后面再详细演示第一个Android Things 工程。
Things的优势 The ease and power of Android  If you can build an app, you can build a device
  The Android ecosystem Leverage existing Android development tools, APIs, resources, and a thriving developer community.</description>
    </item>
    
    <item>
      <title>数据结构——概念和术语</title>
      <link>/blog/2017-02-27-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/</link>
      <pubDate>Mon, 27 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/blog/2017-02-27-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/</guid>
      <description>认识和理解数据结构里面的概念和术语很重要，这篇主要就是在通读课本第一章绪论之后作的简要笔记。
概念和术语  数据(data) 对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号总称，其含义非常广泛，如图像、声音都可以通过编码而归之于数据的范畴 数据元素(data element) 数据的基本单位，在计算机程序中有时候也作为整体进行考虑和处理。数据元素也可以由若干个数据项(data item)组成，如一本书的书目信息是一个数据元素，而信息中每一项（作者、书名等）都是一个数据项，数据项是数据不可分割的最小单位。 数据对象(data object) 性质相同的数据元素的集合，是数据的一个子集。 数据结构(data structure) 相互之间存在的一种或多种特定的关系数据元素的集合。通常有以下四种常见数据结构：1.集合 2.线性结构 3.树形结构 4.图状结构或网状结构   数据结构是一个二元组：Data_Structure = (D,S),其中D是数据元素的有限集，S是D上关系的有限集。
 数据结构在计算机中存储称为数据的物理结构，又称为存储结构，包括数据元素的表示和关系的表示。数据元素之间的关系在计算机中有两种不同的表示方法，分别是：顺序映像和非顺序映像，并由此得到两种不同的存储结构：顺序存储结构和链式存储结构，前者(图1.6.a)是借助元素在存储器中的相对位置表示元素之间的逻辑关系，后者(图1.6.b)借助指示元素存储地址的指针(pointer)表示数据元素之间的逻辑关系。
   算法(aigorithm)是对特定问题求解步骤的一种描述，它是指令的有限序列，具有5个非常重要的特性：(1) 有穷性 在合法输入值下，算法执行有穷步之后结束，并每一步都可以有穷时间内完成。(2) 确定性 任何条件下算法只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出。(3) 可行性 算法中描述的操作都是可以通过已经实现的基本运算执行有限次实现的。 (4) 输入 一个算法会有零个或若干个输入。(5) 输出 一个算法会有一个或若干个输出，这些输出同输入有着某种特定关系。
 算法设计的要求： 正确性(correctness) + 可读性(readability) + 健壮性(robustness) + 效率与低存储量需求。（ps：感觉又学了不少英文单词呢。。。）
 算法效率的度量： (1) 事后统计：一看就不是什么正经方法😄，这种方法误差性太大，和硬件运行环境等关系太大。一般都不用这个。 (2) 事前统计：1. 算法策略 2.问题规模 3.算法语言(一般语言越高级，效率越低) 4.编译机器代码的质量 5.机器指令的执行速度
 时间复杂度 问题规模记为n，算法基本操作执行的重复次数记为f(n),则随着规模n的增大，执行时间的增长率和f(n)的增长率一致，称为算法的渐进时间复杂度(asymptotic time complexity)：T(n) = O(f(n)) eg. (a) {++x;} (b) for(i=1;i&amp;lt;=n;i++) {++x;} &amp;copy; for(j=1;j&amp;lt;=n;j++) for(k=1;k&amp;lt;=n;k++) {++x;} 以上三段程序的时间复杂度分别为：O(1),O(n),O(n^2)，分别称为常量阶、线性阶、平方阶。当然还有其他的对数阶O(log n) 和指数阶O(2^n)等。</description>
    </item>
    
    <item>
      <title>定个小目标——数据结构</title>
      <link>/blog/2017-02-24-%E5%AE%9A%E4%B8%AA%E5%B0%8F%E7%9B%AE%E6%A0%87-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 24 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/blog/2017-02-24-%E5%AE%9A%E4%B8%AA%E5%B0%8F%E7%9B%AE%E6%A0%87-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>作为一名非科班出身的野生程序员，不得不说，在许多基础方面的能力非常的薄弱，虽然很多情况下这并不影响正常的工作，这是因为多数情况的程序工作都是千篇一律的业务代码，很少涉及到更深入的设计。
为什么想起来学数据结构 作为一名非科班出身的野生程序员，不得不说，在许多基础方面的能力非常的薄弱，虽然很多情况下这并不影响正常的工作，这是因为大多数情况下的程序工作都是千篇一律的业务代码，很少涉及到更深入的设计，这导致一个人非常容易走进舒适区并且很难再走出来。这对自己的职业成长是非常不利的。记得之前看到过关于学习的四个成长阶段： 1. 不知道自己不知道 2. 知道自己不知道 3. 知道自己知道 4. 不知道自己知道
很多刚刚入门的程序员还处在第一个阶段，尤其是野生的程序员，可能先学三个月的IDE快速开发，能够做基本的业务，刷一刷常见面试题就上岗去了。在这里并不是说野生程序员能力不行，笔者本人也是半路出身，大二开始自学Java，然后做Android开发，之前大一主要学c和c++，做嵌入式硬件开发，做过虚拟仪器、单片机、fpga、画过pcb，作为机械大类的工科男，还敲过锤子打过铁，制作收音机以及小音箱，还有各种机床操作，这画风不忍直视。。。其实，野生程序员最值得肯定的一点就是超级强的自学能力，自我充电的能力和热情。但是根据我两年的自学经历来讲，野生要想成长为大牛，需要非常非常的努力并且和机智的头脑。 作为一名野生战五渣，就不具体讨论大牛之路了，毕竟我也在朝着目标不断努力，还在路上。这也是我要先系统学习数据结构的原因，本系列文章将主要记录我在学习过程中的笔记，一些概念，想法等等。
怎么学习这本书 我经常会读到一些资源帖之类的文章，标贴多诸如《程序员必看十篇》，《java开发书籍推荐》等等，对于这些，我以前都是收入囊中，点击收藏，mark，有时候还尽量下载到本地储存起来，现在回顾看来，以上这些统统不推荐！阅读经典教材，并做好笔记，而且尽量一次只准备一到两本书放在学习库里面，实际经历告诉我一次性准备很多书籍并无卵用，只是一时激情作祟啊！！都是泪。 本次学习选取的便是众人推荐过严蔚敏的《数据结构》，作为经典教材，决定一边读书一边写笔记。
准备用多长时间 额。。完全不晓得啊～虽然工作时间很弹性，由于本人惰性太大，经常下班回去之后依然会刷刷微博，看看视频，然后看书的时间就没有了。。。至于这篇文章也是预计一周之前要写的，然后拖到现在才写，哈哈哈。。。 so，还是定个小目标吧。这本书共有12章分别是：
 绪论（目测就是一些概念性的东西吧。） 线性表 栈和队列 串（这个竟然没听过。。） 数组和广义表 树和二叉树（这个要好好看看～） 图 动态存储管理 查找 内部排序 外部排序（以上三章估计要结合算法来学习） 文件  好了，就是这些了！大概准备三周的时间来学习吧。整理一下博客发现竟然小半年都没写过东西了，真想好好忏悔一下。毕竟舒适区太舒服了～摔～ 自问自答结束。 以上</description>
    </item>
    
    <item>
      <title>实现View滑动的七种方法</title>
      <link>/blog/2016-09-23-%E5%AE%9E%E7%8E%B0view%E6%BB%91%E5%8A%A8%E7%9A%84%E4%B8%83%E7%A7%8D%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 23 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>/blog/2016-09-23-%E5%AE%9E%E7%8E%B0view%E6%BB%91%E5%8A%A8%E7%9A%84%E4%B8%83%E7%A7%8D%E6%96%B9%E6%B3%95/</guid>
      <description>Android群英传学习笔记，介绍了android坐标系、视图坐标系、onTouch事件分发、layout方法、scrollBy方法、Scroller、ViewDragHelper 等等内容。
Android坐标系 在介绍如何实现View滑动之前先了解一下Android的坐标系，我们在初中数学就学过坐标系，有原点和X轴Y轴，不过屏幕上的坐标系稍微有点区别，移动设备一般将屏幕的左上角定义为原点，向右为X轴正方向，向下为Y轴正方向，如下图：
View坐标系 与屏幕坐标系相同，View也有自己的坐标系，我们可以称之为视图坐标系，描述了本身和父布局的位置关系，原点在View的左上角：
View及MotionEvent坐标获取  View自身坐标获取方法
  getTop()：获取到的，是view自身的顶边到其父布局顶边的距离
 getLeft()：获取到的，是view自身的左边到其父布局左边的距离
 getRight()：获取到的，是view自身的右边到其父布局左边的距离
 getBottom()：获取到的，是view自身的底边到其父布局顶边的距离
   MotionEvent坐标获取
  getX()：获取点击事件相对控件左边的x轴坐标，即点击事件距离控件左边的距离
 getY()：获取点击事件相对控件顶边的y轴坐标，即点击事件距离控件顶边的距离
 getRawX()：获取点击事件相对整个屏幕左边的x轴坐标，即点击事件距离整个屏幕左边的距离
 getRawY()：获取点击事件相对整个屏幕顶边的y轴坐标，即点击事件距离整个屏幕顶边的距离
  说了这么多方法都不如一张图最直接：原图链接
触控事件onTouch 学好触控事件是掌握后续内容的重要基础，触控事件回调的MotionEvent封装了一些常用的事件常量，定义了一些常见类型动作。
/** * A pressed gesture has started, the motion contains the initial starting location. */ public static final int ACTION_DOWN = 0; /** * A pressed gesture has finished, the motion contains the final release location as well as any intermediate * points since the last down or move event.</description>
    </item>
    
    <item>
      <title>RecycleView实现的地区选择模块</title>
      <link>/blog/2016-09-21-recycleview%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%9C%B0%E5%8C%BA%E9%80%89%E6%8B%A9%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Wed, 21 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>/blog/2016-09-21-recycleview%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%9C%B0%E5%8C%BA%E9%80%89%E6%8B%A9%E6%A8%A1%E5%9D%97/</guid>
      <description>最近在做的一个项目里，需要在用户个人资料设置页有选择地区功能，看了一些开源的实现方法，大多还停留在底部弹出Dialog的形式。
感觉并不友好，微信的地区选择界面是本人比较喜欢的展示形式，地区选择的功能应该算是一个基础功能吧，社交类、外卖类等等APP貌似都需要用户输入地址，选择地区等等，所以就想着自己做一个类似的，不足的是没有加入定位功能，以后还有很多要补充，现在先把这一块功能独立出来做个demo，和大家交流学习一下（文末有实用小 公举 工具推荐哦）。
　先上图看一下效果：
　讲一下思路：结构很简单，点击第一个activity的设置地区，开启第二个activity，同时把已经选择的地区传值，格式为“省份　城市　地区”（没有引号），然后地区设置完成后setResult就可以了。地区activity选择用RecycleView实现。
AActivity &amp;lt;----------------onActivityResult() | | startActivityForResult() | | | BActivity----------&amp;gt;setResult()----------&amp;gt;  布局 　和使用ListView差不多，不同的是RecycleView并没有item点击事件，因此这个需要自己实现，这个后面会讲到。ok，第一步实现item布局和ViewHolder，分析一下item需要展示的内容：首先是地名，还有就是后面有没有已选择，不要忽略item的点击事件。
xml布局如下：
&amp;lt;RelativeLayout android:id=&amp;quot;@+id/item_btn&amp;quot; &amp;gt; &amp;lt;TextView android:id=&amp;quot;@+id/item_tv&amp;quot; /&amp;gt; &amp;lt;TextView android:id=&amp;quot;@+id/checked&amp;quot; /&amp;gt; &amp;lt;/RelativeLayout&amp;gt;  ViewHolder如下：
public class RegionViewHolder extends RecyclerView.ViewHolder { public TextView textView; public TextView checked; public ViewGroup itemBtn; public RegionViewHolder(View itemView) { super(itemView); initView(); } private void initView() { textView = (TextView) itemView.findViewById(R.id.item_tv); checked = (TextView) itemView.</description>
    </item>
    
    <item>
      <title>Java里臭名远扬的代码：你认出来了吗[译]？</title>
      <link>/blog/2016-08-22-%E8%AF%91java%E9%87%8C%E8%87%AD%E5%90%8D%E8%BF%9C%E6%89%AC%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BD%A0%E8%AE%A4%E5%87%BA%E6%9D%A5%E4%BA%86%E5%90%97/</link>
      <pubDate>Mon, 22 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>/blog/2016-08-22-%E8%AF%91java%E9%87%8C%E8%87%AD%E5%90%8D%E8%BF%9C%E6%89%AC%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BD%A0%E8%AE%A4%E5%87%BA%E6%9D%A5%E4%BA%86%E5%90%97/</guid>
      <description>八月份的第三个周日，写的第四篇文章，坚持写下去一定会有收获，正所谓，万事开头难、中间难、结尾难。。。
 okay，本周在实际工作中遇到了蛮多的新知识，鉴于每日工作繁忙，周日还要加班，因此只有周六一天可以‘忙中作乐’，不过这个周六依然过得十分‘充足’，上午陪同事找房子忙到下午2点，下午三点去学习游泳学到六点钟。此外，本周抽时间重新布局了我的卧室，安装了一张写字桌，组装一台电脑，现在终于可以在周日的晚上安安静静的写点东西。本周决定翻译一篇dzone.com上面的一篇文章练习一下，下周决定写一篇介绍 Android Notification 的文章，巩固学习。
  阅读本文大概需要 4.5 分钟
  正文  这些违反设计原则和质量的代码结构简直就是臭虫。  下面我们就列举一些常见的臭虫代码。
常量接口（Constant Interface） 常量接口只包含了静态常量数据成员，没有声明任何的方法在里面。建议的重构方式要根据常量接口里面常亮的种类：常量是类里面的成员可以被添加或者是可以被写入的枚举。接口 java.io.ObjectStreamConstant 就是一个很好的例子。
全局变量类（Global Variable Class） 这种类拥有一个公共静态成员（非final），由于这种变量可以被任何人修改，这就变成了类似于 C 语言里面的全局变量，不同的是，在使用前要加上类的名字来防止变量名冲突。下面是一个例子：
class Balls { public static long balls = 0; }  全局方法类 （Global Function Class） 这是一种只有一个静态公共方法没有任何其他的成员或者方法的public修饰的类；他有一个可选的用private属性修饰的构造方法来禁止实例化。这相当于C语言里面的全局函数，除了在使用他时需要在前面加上类的名字。
公共裸露的成员 （Publicly Exposed Fields） 这是一种public修饰的，他的成员都是public修饰的，非final，非static，并且没有任何方法在里面（可能会有一个可选的构造方法），这是难以保持的public修饰、类似C的一些类，正如 Effective Java 中所写道的：“一些java平台库里面的类，忽视public类不应该直接暴露成员的建议。最突出的例子就是 java.awt 包里面的 Point 类和 Dimension 类，这些栗子不是简单的来说说，而是应当被视作严重警示。
孤立的抽象（Orphan Abstract） 这是一个抽象abstract 修饰的没有任何实现类的类，一个抽象类，只有当具体实现的时候，他才能获得‘人生价值’。如果一个抽象类没有任何用处，那么还留你何用（可以移除了）？如果这个类可以考虑实例化，那么就去具体实现；如果这代表一种有用的抽象，就提供若干具体实现类去实现他。
被遗忘的接口 （Forgotten Interface） 一个类用同样的签名实现了所有接口列举的方法。这很有可能是一种失误：类原本是想要实现一个接口，但是忘记列举接口作为他的基本类型。这种臭虫做法的后果就是：该类的对象不能被视作接口的子类，于是，子类型的好处和运行多态都不能被利用。
双胞胎类 （Clone Class） 一个类完完全全克隆另外一个类，不是继承关系。实质上，只是类的名字不太一样，但是他们的全部成员、签名其他等等都是一样的。约束他们的仅仅是至少有一个不同的成员。一个例外就是那个成员顺序可能不太一样。 如果有若干个类拥有共同的成员或者表现，他们应该继承一个共同的类，包含那些共同的数据和表现。因此， 一个解决方法就是看看有没有可能提供一个基类，并且让其他类成为他的派生类 ,克隆类常常发生在复制粘贴代码，在这种情况下，最好就是移除副本，用一个独一无二的类取代。</description>
    </item>
    
    <item>
      <title>我为什么不用百度解决bug</title>
      <link>/blog/2016-08-16-%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E7%99%BE%E5%BA%A6%E8%A7%A3%E5%86%B3bug/</link>
      <pubDate>Tue, 16 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>/blog/2016-08-16-%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E7%99%BE%E5%BA%A6%E8%A7%A3%E5%86%B3bug/</guid>
      <description>选择用百度来解决bug，一定是脑子进了水。 ——记一次难忘的bug调试经历。
问题描述： 开发环境是Android Studio，在做一个智能硬件的客户端APP。 今天做到在线升级部分，添加一个UpdateHelper类，单独做成一个Module，在引用R资源时，发现没有自动生成R文件，之前也遇到过这种情况，一般来说就是资源文件有错误，R文件不能生成，但是这个Module里面我只放了两张png资源图，排除资源错误问题。好吧。。。这种bug的确让人头疼。之后尝试修改文件名、Clean、 Rebuild 、Make 等等，都是扯淡。。。
好吧。。然后我打开了Baidu（百毒），输入关键词
 Android Module 生成 R
 然而，这出来的都是什么结果啊？其实乍一看结果还可以吧，毕竟都和关键词相关，然而内容真的是就像“宝宝的宝宝的宝宝不是宝宝亲生的” ［捂脸］。。。
好吧，既然结果都搜出来了，我们就读读看吧，反正“来都来了”：
 答案一：AndroidStudio library module的R文件报错 - - 博客频道 - CSDN.NET
 错误的内容主要是case R.styleable.这两句报错，一开始我还以为是library module的R文件没有生成。 又是clean project又是rebuild project.都没用。后来我发现TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.GradientIconView); 这句没有报错，原来是我把问题定位错了，问题不是R文件没有生成，而是case R.styleable.这句有问题。
天哪，允许我做一个悲伤的表情😢。。。这。。。和 Module 生成 R 文件 有半毛钱的关系？
 答案二：android studio新建Module不生成build文件夹 - JustDoItToday的&amp;hellip;
 这个题目终于看上去靠谱点了！我们来看一下原文：
噗～真的是一口老血喷你脸上，😢，天哪，当创建第五个时不会生成Build文件夹，妈勒个蛋，这个到底是为什么啊？Why？最关键的是：竟然有人在下面评论：
噗～大兄弟，你真的解决了嘛？
其他的就不继续列觉了，这逼装的简直刺眼。。。
于是，楼主默默的打开Google。
哇塞！第一个结果貌似就是我想要的啊！我点进去看看～
 Android Studio don&amp;rsquo;t generate R.java for my import project
 看到这第一个答案，其实我的问题就快解决了。然后我 File -&amp;gt; Settings -&amp;gt; Compiler now check use external build ，妈蛋啊，没有这个选项呀？不带这样玩的啊。。。</description>
    </item>
    
    <item>
      <title>equals 方法里面的“坑”</title>
      <link>/blog/2016-08-11-equals%E6%96%B9%E6%B3%95%E7%9A%84%E5%9D%91/</link>
      <pubDate>Thu, 11 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>/blog/2016-08-11-equals%E6%96%B9%E6%B3%95%E7%9A%84%E5%9D%91/</guid>
      <description>今天遇到一个比较细节的bug，稍微有点基础的都知道 == 和 equals 的用法，前者用于比较基础数据类型值是否相等，当用于引用类型的时候，一般比较的都是引用地址，因此我们在比较两个对象是否相等时就用后者。然而。。。
先来看一段代码：
Integer n1 = new Integer(21); Integer n2 = new Integer(21); System.out.println(n1 == n2); System.out.println(n1.equals(n2));  不难知道。前者比较的引用，返回false，后者比较的内容，返回true；
下面，我们自定义一个Student类：
class Student { private String name; private int age; public Student(String name,int age) { this.name = name; this.age = age; } }  省略掉了setter和getter，然后我们再来new两个对象比较一下：
Student s1 = new Student(&amp;quot;Big&amp;quot;,21); Student s2 = new Student(&amp;quot;Big&amp;quot;,21); System.out.println(s1 == s2); System.out.println(s1.equals(s2));  你能猜到打印的结果吗？两个都是false！这就很费解了，为什么equals不好使了呢？这是因为：
 因为equals()方法默认行为是比较引用，因此在新类中要自己重写equals()方法，否则不可能表现出我们希望的行为。 ——《Thinking in Java》3.7.1
 OK，到这里我们就发现了原因了，我们在Student类中添加一个equals方法：</description>
    </item>
    
  </channel>
</rss>