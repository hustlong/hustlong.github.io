<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>充电笔记 on 龙大侠</title>
    <link>/tags/%E5%85%85%E7%94%B5%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 充电笔记 on 龙大侠</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 29 Jun 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/%E5%85%85%E7%94%B5%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>经典排序算法总结与Go实现</title>
      <link>/blog/2017-06-29-%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ego%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Thu, 29 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/blog/2017-06-29-%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ego%E5%AE%9E%E7%8E%B0/</guid>
      <description>学习Go语言第二周，本周任务尝试实现七大经典排序算法以及分析算法复杂度、优劣及应用场景等，七大经典算法分别为冒泡排序，插入排序，选择排序，希尔排序，归并排序，快速排序，堆排序。 冒泡排序  思路  正如“冒泡”二字，我的理解是重复依次比较相邻的两个数，大的数放在后面，小的数放在前面，一直重复到没有任何一对数字需要交换位置为止。就像冒泡一样，大的数不断浮上来。
 伪代码  do swapped = false for i = 1 to indexOfLastUnsortedElement-1 if leftElement &amp;gt; rightElement swap(leftElement, rightElement) swapped = true; swapCounter++ while swapped   Go实现  func Bubble_Sort(arr []int) { swapped := true len := len(arr) for swapped { swapped = false for i := 0; i &amp;lt; len-1; i++ { if arr[i] &amp;gt; arr[i+1] { arr[i], arr[i+1] = arr[i+1], arr[i] swapped = true } } } }  选择排序  思路  先假设第一个元素为最小值，然后与剩余的 len-1 个元素依次进行比较，标记最小数的位置，如果有更小的数，则在进行下一轮遍历比较之前交换位置。</description>
    </item>
    
    <item>
      <title>数据结构——概念和术语</title>
      <link>/blog/2017-02-27-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/</link>
      <pubDate>Mon, 27 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/blog/2017-02-27-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD/</guid>
      <description>认识和理解数据结构里面的概念和术语很重要，这篇主要就是在通读课本第一章绪论之后作的简要笔记。
概念和术语  数据(data) 对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号总称，其含义非常广泛，如图像、声音都可以通过编码而归之于数据的范畴 数据元素(data element) 数据的基本单位，在计算机程序中有时候也作为整体进行考虑和处理。数据元素也可以由若干个数据项(data item)组成，如一本书的书目信息是一个数据元素，而信息中每一项（作者、书名等）都是一个数据项，数据项是数据不可分割的最小单位。 数据对象(data object) 性质相同的数据元素的集合，是数据的一个子集。 数据结构(data structure) 相互之间存在的一种或多种特定的关系数据元素的集合。通常有以下四种常见数据结构：1.集合 2.线性结构 3.树形结构 4.图状结构或网状结构   数据结构是一个二元组：Data_Structure = (D,S),其中D是数据元素的有限集，S是D上关系的有限集。
 数据结构在计算机中存储称为数据的物理结构，又称为存储结构，包括数据元素的表示和关系的表示。数据元素之间的关系在计算机中有两种不同的表示方法，分别是：顺序映像和非顺序映像，并由此得到两种不同的存储结构：顺序存储结构和链式存储结构，前者(图1.6.a)是借助元素在存储器中的相对位置表示元素之间的逻辑关系，后者(图1.6.b)借助指示元素存储地址的指针(pointer)表示数据元素之间的逻辑关系。
   算法(aigorithm)是对特定问题求解步骤的一种描述，它是指令的有限序列，具有5个非常重要的特性：(1) 有穷性 在合法输入值下，算法执行有穷步之后结束，并每一步都可以有穷时间内完成。(2) 确定性 任何条件下算法只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出。(3) 可行性 算法中描述的操作都是可以通过已经实现的基本运算执行有限次实现的。 (4) 输入 一个算法会有零个或若干个输入。(5) 输出 一个算法会有一个或若干个输出，这些输出同输入有着某种特定关系。
 算法设计的要求： 正确性(correctness) + 可读性(readability) + 健壮性(robustness) + 效率与低存储量需求。（ps：感觉又学了不少英文单词呢。。。）
 算法效率的度量： (1) 事后统计：一看就不是什么正经方法😄，这种方法误差性太大，和硬件运行环境等关系太大。一般都不用这个。 (2) 事前统计：1. 算法策略 2.问题规模 3.算法语言(一般语言越高级，效率越低) 4.编译机器代码的质量 5.机器指令的执行速度
 时间复杂度 问题规模记为n，算法基本操作执行的重复次数记为f(n),则随着规模n的增大，执行时间的增长率和f(n)的增长率一致，称为算法的渐进时间复杂度(asymptotic time complexity)：T(n) = O(f(n)) eg. (a) {++x;} (b) for(i=1;i&amp;lt;=n;i++) {++x;} &amp;copy; for(j=1;j&amp;lt;=n;j++) for(k=1;k&amp;lt;=n;k++) {++x;} 以上三段程序的时间复杂度分别为：O(1),O(n),O(n^2)，分别称为常量阶、线性阶、平方阶。当然还有其他的对数阶O(log n) 和指数阶O(2^n)等。</description>
    </item>
    
    <item>
      <title>定个小目标——数据结构</title>
      <link>/blog/2017-02-24-%E5%AE%9A%E4%B8%AA%E5%B0%8F%E7%9B%AE%E6%A0%87-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 24 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/blog/2017-02-24-%E5%AE%9A%E4%B8%AA%E5%B0%8F%E7%9B%AE%E6%A0%87-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>作为一名非科班出身的野生程序员，不得不说，在许多基础方面的能力非常的薄弱，虽然很多情况下这并不影响正常的工作，这是因为多数情况的程序工作都是千篇一律的业务代码，很少涉及到更深入的设计。
为什么想起来学数据结构 作为一名非科班出身的野生程序员，不得不说，在许多基础方面的能力非常的薄弱，虽然很多情况下这并不影响正常的工作，这是因为大多数情况下的程序工作都是千篇一律的业务代码，很少涉及到更深入的设计，这导致一个人非常容易走进舒适区并且很难再走出来。这对自己的职业成长是非常不利的。记得之前看到过关于学习的四个成长阶段： 1. 不知道自己不知道 2. 知道自己不知道 3. 知道自己知道 4. 不知道自己知道
很多刚刚入门的程序员还处在第一个阶段，尤其是野生的程序员，可能先学三个月的IDE快速开发，能够做基本的业务，刷一刷常见面试题就上岗去了。在这里并不是说野生程序员能力不行，笔者本人也是半路出身，大二开始自学Java，然后做Android开发，之前大一主要学c和c++，做嵌入式硬件开发，做过虚拟仪器、单片机、fpga、画过pcb，作为机械大类的工科男，还敲过锤子打过铁，制作收音机以及小音箱，还有各种机床操作，这画风不忍直视。。。其实，野生程序员最值得肯定的一点就是超级强的自学能力，自我充电的能力和热情。但是根据我两年的自学经历来讲，野生要想成长为大牛，需要非常非常的努力并且和机智的头脑。 作为一名野生战五渣，就不具体讨论大牛之路了，毕竟我也在朝着目标不断努力，还在路上。这也是我要先系统学习数据结构的原因，本系列文章将主要记录我在学习过程中的笔记，一些概念，想法等等。
怎么学习这本书 我经常会读到一些资源帖之类的文章，标贴多诸如《程序员必看十篇》，《java开发书籍推荐》等等，对于这些，我以前都是收入囊中，点击收藏，mark，有时候还尽量下载到本地储存起来，现在回顾看来，以上这些统统不推荐！阅读经典教材，并做好笔记，而且尽量一次只准备一到两本书放在学习库里面，实际经历告诉我一次性准备很多书籍并无卵用，只是一时激情作祟啊！！都是泪。 本次学习选取的便是众人推荐过严蔚敏的《数据结构》，作为经典教材，决定一边读书一边写笔记。
准备用多长时间 额。。完全不晓得啊～虽然工作时间很弹性，由于本人惰性太大，经常下班回去之后依然会刷刷微博，看看视频，然后看书的时间就没有了。。。至于这篇文章也是预计一周之前要写的，然后拖到现在才写，哈哈哈。。。 so，还是定个小目标吧。这本书共有12章分别是：
 绪论（目测就是一些概念性的东西吧。） 线性表 栈和队列 串（这个竟然没听过。。） 数组和广义表 树和二叉树（这个要好好看看～） 图 动态存储管理 查找 内部排序 外部排序（以上三章估计要结合算法来学习） 文件  好了，就是这些了！大概准备三周的时间来学习吧。整理一下博客发现竟然小半年都没写过东西了，真想好好忏悔一下。毕竟舒适区太舒服了～摔～ 自问自答结束。 以上</description>
    </item>
    
  </channel>
</rss>