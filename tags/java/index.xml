<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 龙大侠</title>
    <link>/tags/java/</link>
    <description>Recent content in Java on 龙大侠</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 22 Aug 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java里臭名远扬的代码：你认出来了吗[译]？</title>
      <link>/blog/2016-08-22-%E8%AF%91java%E9%87%8C%E8%87%AD%E5%90%8D%E8%BF%9C%E6%89%AC%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BD%A0%E8%AE%A4%E5%87%BA%E6%9D%A5%E4%BA%86%E5%90%97/</link>
      <pubDate>Mon, 22 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>/blog/2016-08-22-%E8%AF%91java%E9%87%8C%E8%87%AD%E5%90%8D%E8%BF%9C%E6%89%AC%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BD%A0%E8%AE%A4%E5%87%BA%E6%9D%A5%E4%BA%86%E5%90%97/</guid>
      <description>八月份的第三个周日，写的第四篇文章，坚持写下去一定会有收获，正所谓，万事开头难、中间难、结尾难。。。
 okay，本周在实际工作中遇到了蛮多的新知识，鉴于每日工作繁忙，周日还要加班，因此只有周六一天可以‘忙中作乐’，不过这个周六依然过得十分‘充足’，上午陪同事找房子忙到下午2点，下午三点去学习游泳学到六点钟。此外，本周抽时间重新布局了我的卧室，安装了一张写字桌，组装一台电脑，现在终于可以在周日的晚上安安静静的写点东西。本周决定翻译一篇dzone.com上面的一篇文章练习一下，下周决定写一篇介绍 Android Notification 的文章，巩固学习。
  阅读本文大概需要 4.5 分钟
  正文  这些违反设计原则和质量的代码结构简直就是臭虫。  下面我们就列举一些常见的臭虫代码。
常量接口（Constant Interface） 常量接口只包含了静态常量数据成员，没有声明任何的方法在里面。建议的重构方式要根据常量接口里面常亮的种类：常量是类里面的成员可以被添加或者是可以被写入的枚举。接口 java.io.ObjectStreamConstant 就是一个很好的例子。
全局变量类（Global Variable Class） 这种类拥有一个公共静态成员（非final），由于这种变量可以被任何人修改，这就变成了类似于 C 语言里面的全局变量，不同的是，在使用前要加上类的名字来防止变量名冲突。下面是一个例子：
class Balls { public static long balls = 0; }  全局方法类 （Global Function Class） 这是一种只有一个静态公共方法没有任何其他的成员或者方法的public修饰的类；他有一个可选的用private属性修饰的构造方法来禁止实例化。这相当于C语言里面的全局函数，除了在使用他时需要在前面加上类的名字。
公共裸露的成员 （Publicly Exposed Fields） 这是一种public修饰的，他的成员都是public修饰的，非final，非static，并且没有任何方法在里面（可能会有一个可选的构造方法），这是难以保持的public修饰、类似C的一些类，正如 Effective Java 中所写道的：“一些java平台库里面的类，忽视public类不应该直接暴露成员的建议。最突出的例子就是 java.awt 包里面的 Point 类和 Dimension 类，这些栗子不是简单的来说说，而是应当被视作严重警示。
孤立的抽象（Orphan Abstract） 这是一个抽象abstract 修饰的没有任何实现类的类，一个抽象类，只有当具体实现的时候，他才能获得‘人生价值’。如果一个抽象类没有任何用处，那么还留你何用（可以移除了）？如果这个类可以考虑实例化，那么就去具体实现；如果这代表一种有用的抽象，就提供若干具体实现类去实现他。
被遗忘的接口 （Forgotten Interface） 一个类用同样的签名实现了所有接口列举的方法。这很有可能是一种失误：类原本是想要实现一个接口，但是忘记列举接口作为他的基本类型。这种臭虫做法的后果就是：该类的对象不能被视作接口的子类，于是，子类型的好处和运行多态都不能被利用。
双胞胎类 （Clone Class） 一个类完完全全克隆另外一个类，不是继承关系。实质上，只是类的名字不太一样，但是他们的全部成员、签名其他等等都是一样的。约束他们的仅仅是至少有一个不同的成员。一个例外就是那个成员顺序可能不太一样。 如果有若干个类拥有共同的成员或者表现，他们应该继承一个共同的类，包含那些共同的数据和表现。因此， 一个解决方法就是看看有没有可能提供一个基类，并且让其他类成为他的派生类 ,克隆类常常发生在复制粘贴代码，在这种情况下，最好就是移除副本，用一个独一无二的类取代。</description>
    </item>
    
    <item>
      <title>equals 方法里面的“坑”</title>
      <link>/blog/2016-08-11-equals%E6%96%B9%E6%B3%95%E7%9A%84%E5%9D%91/</link>
      <pubDate>Thu, 11 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>/blog/2016-08-11-equals%E6%96%B9%E6%B3%95%E7%9A%84%E5%9D%91/</guid>
      <description>今天遇到一个比较细节的bug，稍微有点基础的都知道 == 和 equals 的用法，前者用于比较基础数据类型值是否相等，当用于引用类型的时候，一般比较的都是引用地址，因此我们在比较两个对象是否相等时就用后者。然而。。。
先来看一段代码：
Integer n1 = new Integer(21); Integer n2 = new Integer(21); System.out.println(n1 == n2); System.out.println(n1.equals(n2));  不难知道。前者比较的引用，返回false，后者比较的内容，返回true；
下面，我们自定义一个Student类：
class Student { private String name; private int age; public Student(String name,int age) { this.name = name; this.age = age; } }  省略掉了setter和getter，然后我们再来new两个对象比较一下：
Student s1 = new Student(&amp;quot;Big&amp;quot;,21); Student s2 = new Student(&amp;quot;Big&amp;quot;,21); System.out.println(s1 == s2); System.out.println(s1.equals(s2));  你能猜到打印的结果吗？两个都是false！这就很费解了，为什么equals不好使了呢？这是因为：
 因为equals()方法默认行为是比较引用，因此在新类中要自己重写equals()方法，否则不可能表现出我们希望的行为。 ——《Thinking in Java》3.7.1
 OK，到这里我们就发现了原因了，我们在Student类中添加一个equals方法：</description>
    </item>
    
  </channel>
</rss>